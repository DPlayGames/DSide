DSide.Node=CLASS(e=>{let t=()=>{let e=new Date;return e.getTime()+6e4*e.getTimezoneOffset()};return{init:(e,a,n)=>{let o,i,r=(n.tokenName,n.socketServerPort),s=n.webSocketServerPort,d=n.version,u=n.accountAddress,c=n.dataStructures,f=DSide.Data.DataManager(c),D=n.ips;MULTI_PROTOCOL_SOCKET_SERVER({socketServerPort:r,webServer:WEB_SERVER(s)},(e,a,n,r,s)=>{a("getClientIp",(t,a)=>{void 0!==t&&void 0===o&&(o={},i={},o[t]={connectTime:new Date,accountAddress:u}),a(e.ip)}),a("connectNode",(t,a)=>{void 0!==o&&(o[e.ip]={connectTime:new Date,accountAddress:t},T(e.ip,t))}),a("getVersion",(e,t)=>{t(d)}),a("getNowUTC",(e,a)=>{a(t())}),a("getIpInfos",(e,t)=>{void 0!==o&&t({ipInfos:o,connectionTimes:i})}),a("getTokenStoreHash",(e,t)=>{t(DSide.Data.TokenStore.getHash())}),a("getTokenAccounts",(e,t)=>{t(DSide.Data.TokenStore.getAccounts())}),a("getStoreHash",(e,t)=>{t(f.getStoreHash(e))}),a("getDataSet",(e,t)=>{t(f.getDataSet(e))}),a("saveData",(e,a)=>{let n=e.data,o=e.isFromNode,i=n.createTime;if(t()-i.getTime()<5e3){let t=f.saveData(e);o!==!0&&void 0!==t.savedData&&(e.isFromNode=!0,EACH(m,t=>{t.send({methodName:"saveData",data:e})})),a(t)}else a({isTimeout:!0})}),a("getData",(e,t)=>{t(f.getData(e))}),a("updateData",(e,a)=>{let n=e.originHash,o=e.signature,i=(e.hash,e.data),r=e.isFromNode,s=i.address,d=i.lastUpdateTime;if(t()-d.getTime()<5e3)if(DSide.Data.Verify({signature:o,address:s,data:n})===!0){let t=f.updateData(e);r!==!0&&void 0!==t.savedData&&(e.isFromNode=!0,EACH(m,t=>{t.send({methodName:"updateData",data:e})})),a(t)}else a({isNotVerified:!0});else a({isTimeout:!0})}),a("removeData",(e,t)=>{let a=(e.storeName,e.target,e.hash),n=e.signature,o=e.address,i=e.isFromNode;if(DSide.Data.Verify({signature:n,address:o,data:a})===!0){let a=f.removeData(e);i!==!0&&void 0!==a.originData&&(e.isFromNode=!0,EACH(m,t=>{t.send({methodName:"removeData",data:e})})),t(a)}else t({isNotVerified:!0})}),a("getTokenBalance",(e,t)=>{t(DSide.Data.TokenStore.getBalance(e))}),a("transferToken",(e,t)=>{let a=e.isFromNode;DSide.Data.TokenStore.transfer(e)===!0?(a!==!0&&void 0!==result.originData&&(e.isFromNode=!0,EACH(m,t=>{t.send({methodName:"transferToken",data:e})})),t({isDone:!0})):t({isNotVerified:!0})})});let S=e=>{e("getTokenStoreHash",t=>{DSide.Data.TokenStore.getHash()!==t&&e("getTokenAccounts",e=>{EACH(e,(e,t)=>{let a=DSide.Data.TokenStore.getBalance(t);a!==e&&DSide.Data.TokenStore.increaseToken({address:t,amount:e-a})}),EACH(DSide.Data.TokenStore.getAccounts(),(t,a)=>{void 0===e[a]&&DSide.Data.TokenStore.removeAccount(a)})})})},g=(e,t)=>{let a=c[e];t({methodName:"getStoreHash",data:e},n=>{f.getStoreHash(e)!==n&&("TargetStore"===a.type?t({methodName:"getDataSet",data:e},a=>{let n=f.getDataSet(e);EACH(a,(a,o)=>{n[o]!==a&&t({methodName:"getDataSet",data:{storeName:e,target:o}},t=>{let a=f.getDataSet({storeName:e,target:o});EACH(t,(e,t)=>{void 0===a[t]&&f.saveData({hash:t,data:e,isForSync:!0})}),EACH(a,(a,n)=>{void 0===t[n]&&f.removeData({storeName:e,target:o,hash:n})})})}),EACH(n,(t,n)=>{void 0===a[n]&&f.removeTarget({storeName:e,target:n})})}):t({methodName:"getDataSet",data:e},t=>{let a=f.getDataSet(e);EACH(t,(e,t)=>{void 0===a[t]&&f.saveData({hash:t,data:e,isForSync:!0})}),EACH(a,(a,n)=>{void 0===t[n]&&f.removeData({storeName:e,hash:n})})}))})},m=[],T=(e,t,a)=>{CONNECT_TO_SOCKET_SERVER({host:e,port:r},{error:()=>{delete i[t],delete o[e]},success:(n,r,s,u)=>{s("getVersion",c=>{if(c===d){let d={accountAddress:t,on:n,off:r,send:s,disconnect:u};m.push(d),n("__DISCONNECTED",()=>{REMOVE({array:m,value:d}),void 0!==o[e]&&(void 0===i[t]&&(i[t]=0),i[t]+=Date.now()-o[e].connectTime.getTime(),delete o[e])}),void 0!==a&&a(d)}else u(),delete i[t],delete o[e]})}})};NEXT([e=>{let t=!1;EACH(D,a=>{CONNECT_TO_SOCKET_SERVER({host:a,port:r},{error:()=>{},success:(n,o,i,r)=>{i({methodName:"getClientIp",data:a},n=>{a!==n&&"192.168."!==n.substring(0,8)&&t!==!0?(e(n,i,r),t=!0):r()})}})})},e=>{return(t,a,n)=>{a("getIpInfos",a=>{o=a.ipInfos,i=a.connectionTimes;let r=!0;EACH(o,(a,o)=>{o!==t?T(o,a.accountAddress,t=>{t.send({methodName:"connectNode",data:u}),r===!0&&(e(),r=!1)}):n()}),o[t]={connectTime:new Date,accountAddress:u},n()})}},()=>{return()=>{let e=(e,t)=>{m.length>0&&m[0].send(e,t)};S(e),EACH(c,(t,a)=>{g(a,e)})}}]),INTERVAL(1,RAR(()=>{let e=CALENDAR(new Date(t()));if(0===e.getHour()&&0===e.getMinute()&&0===e.getSecond()){DSide.Data.TokenStore.chargeLacks(),EACH(o,(e,t)=>{void 0===i[e.accountAddress]&&(i[e.accountAddress]=0),i[e.accountAddress]+=Date.now()-e.connectTime.getTime(),e.connectionTime=new Date}),EACH(i,(e,t)=>{DSide.Data.TokenStore.chargeNodeReward({address:t,connectionTime:e})}),i={};let e=DSide.Data.TokenStore.getHash(),t={};t[e]=DSide.Data.TokenStore.getBalance(u);let a={};a[e]=[],PARALLEL(m,[(e,n)=>{let o=!1;e.send("getTokenStoreHash",i=>{o!==!0&&(void 0===t[i]&&(t[i]=0),void 0===a[i]&&(a[i]=[]),t[i]+=DSide.Data.TokenStore.getBalance(e.accountAddress),a[i].push(e),n(),o=!0)}),DELAY(5,()=>{o!==!0&&(n(),o=!0)})},()=>{let e,n=-1;EACH(t,(t,a)=>{n<a&&(a=n,e=t)}),S((t,n)=>{EACH(a[e],e=>{if(CHECK_IS_IN({array:m,value:e})===!0)return e.send(t,n),!1})})}]),EACH(c,(e,t)=>{let a=f.getStoreHash(t),n={};n[a]=DSide.Data.TokenStore.getBalance(u);let o={};o[a]=[],PARALLEL(m,[(e,a)=>{let i=!1;e.send({methodName:"getStoreHash",data:t},t=>{i!==!0&&(void 0===n[t]&&(n[t]=0),void 0===o[t]&&(o[t]=[]),n[t]+=DSide.Data.TokenStore.getBalance(e.accountAddress),o[t].push(e),a(),i=!0)}),DELAY(5,()=>{i!==!0&&(a(),i=!0)})},()=>{let e,a=-1;EACH(n,(t,n)=>{a<n&&(n=a,e=t)}),g(t,(t,a)=>{EACH(o[e],e=>{if(CHECK_IS_IN({array:m,value:e})===!0)return e.send(t,a),!1})})}])})}}))}}}),DSide("Data").DataManager=CLASS({init:(e,t,a)=>{let n={};EACH(a,(e,t)=>{"TargetStore"===e.type?n[t]=DSide.Data.TargetStore({storeName:t,structure:e.structure}):"TimeoutStore"===e.type?n[t]=DSide.Data.TimeoutStore({storeName:t,structure:e.structure}):n[t]=DSide.Data.Store({storeName:t,structure:e.structure})});t.getStoreHash=(e=>{let t=n[e];return t.getHash()}),t.getDataSet=(e=>{let t,a;CHECK_IS_DATA(e)!==!0?t=e:(t=e.storeName,a=e.target);let o=n[t];return o.getDataSet(a)}),t.saveData=(e=>{let t=e.hash,a=e.data,o=e.isForSync,i=a.storeName,r=a.target,s=n[i];return s.saveData({target:r,hash:t,data:a,isForSync:o})}),t.getData=(e=>{let t=e.storeName,a=e.target,o=e.hash,i=n[t];return void 0===a?i.getData(o):i.getData({target:a,hash:o})}),t.updateData=(e=>{let t=e.hash,a=e.data,o=a.storeName,i=a.target,r=n[o];return r.updateData({target:i,hash:t,data:a})}),t.removeData=(e=>{let t=e.storeName,a=e.target,o=e.hash,i=n[t];return void 0===a?i.removeData(o):i.removeData({target:a,hash:o})}),t.removeTarget=(e=>{let t=e.storeName,a=e.target,o=n[t];o.removeTarget(a)})}}),DSide("Data").Store=CLASS(e=>{const t=require("ethereumjs-util");let a=e.generateHash=(e=>{return"0x"+t.keccak256(STRINGIFY(e)).toString("hex")});return{preset:e=>{let t=e.structure;t.storeName={notEmpty:!0,size:{max:256}},t.address={notEmpty:!0,size:42},t.createTime={notEmpty:!0,date:!0},t.lastUpdateTime={date:!0}},init:(e,t,n)=>{let o=n.storeName,i=n.structure,r=VALID(i),s={},d=!1;READ_FILE({path:"data/"+o+".json",isSync:!0},{notExists:()=>{},success:e=>{s=PARSE_STR(e.toString())}});let u=(t.getHash=(()=>{return a(s)}),t.getDataSet=(()=>{return s}),t.checkValid=(e=>{let t=r.checkAndWash(e);return{isValid:t.checkHasError()!==!0,validErrors:t.getErrors()}})),c=(t.saveData=(e=>{let t=e.hash,a=e.data,n=e.isForSync,o=u(a);if(o.isValid===!0){let e=a.address;return n===!0||void 0!==a.createTime&&void 0===a.lastUpdateTime&&DSide.Data.Verify({signature:t,address:e,data:a})===!0?DSide.Data.TokenStore.useToken({address:e,amount:1})===!0?(s[t]=a,d=!0,{savedData:a}):{isNotEnoughToken:!0}:{isNotVerified:!0}}return{validErrors:o.validErrors}}),t.getData=(e=>{return s[e]})),f=(t.updateData=(e=>{let t=e.originHash,a=e.hash,n=e.data,o=u(n);if(o.isValid===!0){let e=n.address,o=n.createTime,i=n.lastUpdateTime,r=c(t);return void 0!==r?r.createTime===o&&void 0!==i&&DSide.Data.Verify({hash:a,address:e,data:n})===!0?DSide.Data.TokenStore.useToken({address:e,amount:1})===!0?(f(t),s[a]=n,d=!0,{originData:r,savedData:n}):{isNotEnoughToken:!0}:{isNotVerified:!0}:{isNotExists:!0}}return{validErrors:o.validErrors}}),t.removeData=(e=>{let t=c(originHash);return void 0!==t?(delete s[e],d=!0,{originData:t}):{isNotExists:!0}}));e.setToSave=(()=>{d=!0});DELAY(RANDOM(10),()=>{INTERVAL(10,RAR(()=>{d===!0&&(WRITE_FILE({path:"data/"+o+".json",content:STRINGIFY(s)}),d=!1)}))})}}}),DSide("Data").TargetStore=CLASS({preset:e=>{let t=e.structure;return t.target={notEmpty:!0,size:{max:256}},DSide.Data.Store},init:(e,t,a)=>{let n=a.storeName,o=t.getDataSet(),i={};EACH(o,(e,t)=>{READ_FILE({path:"data/"+n+"/"+t+".json",isSync:!0},{notExists:()=>{},success:e=>{i[t]=PARSE_STR(e.toString())}})});let r,s={},d=t=>{void 0===i[t]?delete o[t]:o[t]=DSide.Data.Store.generateHash(i[t]),s[t]=!0,e.setToSave()};OVERRIDE(t.getDataSet,e=>{r=t.getDataSet=(t=>{return void 0!==t?void 0===i[t]?{}:i[t]:e()})});let u;OVERRIDE(t.saveData,e=>{u=t.saveData=(e=>{let a=e.hash,n=e.data,o=e.isForSync,r=t.checkValid(n);if(r.isValid===!0){let e=n.target,t=n.address;return void 0!==n.createTime&&void 0===n.lastUpdateTime&&DSide.Data.Verify({signature:a,address:t,data:n})===!0?o===!0||DSide.Data.TokenStore.useToken({address:t,amount:1})===!0?(void 0===i[e]&&(i[e]={}),i[e][a]=n,d(e),{savedData:n}):{isNotEnoughToken:!0}:{isNotVerified:!0}}return{validErrors:r.validErrors}})});let c;OVERRIDE(t.getData,e=>{c=t.getData=(e=>{let t=e.target,a=e.hash;if(void 0!==i[t])return i[t][a]})});let f;OVERRIDE(t.updateData,e=>{f=t.updateData=(e=>{let a=e.originHash,n=e.hash,o=e.data,r=t.checkValid(o);if(r.isValid===!0){let e,t=o.target,r=o.address,s=o.createTime,u=o.lastUpdateTime;return void 0!==i[t]&&(e=i[t][a]),void 0!==e?e.createTime===s&&void 0!==u&&DSide.Data.Verify({signature:n,address:r,data:o})===!0?DSide.Data.TokenStore.useToken({address:r,amount:1})===!0?(delete i[t][a],i[t][n]=o,d(t),{originData:e,savedData:o}):{isNotEnoughToken:!0}:{isNotVerified:!0}:{isNotExists:!0}}return{validErrors:r.validErrors}})});let D;OVERRIDE(t.removeData,e=>{D=t.removeData=(e=>{let t=c(e);if(void 0!==t){let a=e.target,n=e.hash;return delete i[a][n],CHECK_IS_EMPTY_DATA(i[a])===!0&&delete i[a],d(a),{originData:t}}return{isNotExists:!0}})});t.removeTarget=(e=>{delete i[e],d(e)});INTERVAL(10,()=>{EACH(s,(e,t)=>{e===!0&&(void 0===i[t]?REMOVE_FILE("data/"+n+"/"+t+".json"):WRITE_FILE({path:"data/"+n+"/"+t+".json",content:STRINGIFY(i[t])}),delete s[t])})})}}),DSide("Data").TimeoutStore=CLASS(e=>{let t=()=>{let e=new Date;return e.getTime()+6e4*e.getTimezoneOffset()};return{preset:()=>{return DSide.Data.Store},init:(e,a,n)=>{let o=n.timelimit;INTERVAL(1,()=>{EACH(a.getDataSet(),(e,n)=>{t()-e.createTime.getTime()>1e3*o&&a.remove(n)})})}}}),DSide("Data").TokenStore=OBJECT({init:(e,t)=>{const a=20;let n={},o=!1;READ_FILE({path:"data/Token.json",isSync:!0},{notExists:()=>{},success:e=>{n=PARSE_STR(e.toString())}});let i=(t.getHash=(()=>{return DSide.Data.Store.generateHash(n)}),t.getAccounts=(()=>{return n}),t.getBalance=(e=>{return e=e.toLowerCase(),void 0!==n[e]?n[e]:a})),r=(t.transfer=(e=>{let t=e.address,a=e.hash,n=e.to,o=e.amount;return t=t.toLowerCase(),DSide.Data.Verify({signature:a,address:t,data:{to:n,amount:o}})===!0&&i(t)>=o+1&&(r({address:t,amount:o+1}),void s({address:n,amount:o}))}),t.useToken=(e=>{let t=e.address,a=e.amount;return t=t.toLowerCase(),s({address:t,amount:-a})})),s=t.increaseToken=(e=>{let t=e.address,r=e.amount;return t=t.toLowerCase(),i(t)+r>=0&&(void 0===n[t]&&(n[t]=a),n[t]+=r,o=!0,!0)}),d=t.removeAccount=(e=>{e=e.toLowerCase(),delete n[e],o=!0});t.chargeLacks=(()=>{EACH(n,(e,t)=>{e<20&&d(t)})}),t.chargeNodeReward=(e=>{let t=e.address,a=e.connectionTime;t=t.toLowerCase(),s({address:t,amount:INTEGER(a/1e3/60/60*20)})});DELAY(RANDOM(10),()=>{INTERVAL(10,RAR(()=>{o===!0&&(WRITE_FILE({path:"data/Token.json",content:STRINGIFY(n)}),o=!1)}))})}}),DSide("Data").Verify=METHOD(e=>{const t=require("ethereumjs-util");return{run:e=>{let a,n=e.signature,o=e.address,i=e.data;if(CHECK_IS_DATA(i)===!0){let e={};Object.keys(i).sort().forEach(t=>{e[t]=i[t]}),a=STRINGIFY(e)}else a=i;let r=t.fromRpcSig(n),s=Buffer.from(a),d=Buffer.from("Ethereum Signed Message:\n"),u=t.keccak256(Buffer.concat([d,Buffer.from(String(s.length)),s])),c=t.ecrecover(u,r.v,r.r,r.s);return o.toLowerCase()===t.bufferToHex(t.pubToAddress(c))}}});